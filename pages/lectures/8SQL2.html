<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced SQL - CSCI 5603</title>
    
    <!-- Database Design Presentation Styles with Theme Support -->
    <link rel="stylesheet" href="/styles/presentation.css">
    <link rel="icon" type="image/x-icon" href="/images/favicon.png">
    
    <!-- Import Courier Prime for analog feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=IBM+Plex+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lecture-Specific Styles -->
    <style>
        /* Override font for analog feel */
        body, .slide, h1, h2, h3, p, li {
            font-family: 'Courier Prime', 'IBM Plex Mono', 'Courier New', monospace !important;
        }
        
        /* SQL syntax highlighting classes now in presentation.css */

        .table-result {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
        }
        
        .table-result th {
            background: var(--ocu-true-blue);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 600;
        }
        
        .table-result td {
            border: 1px solid var(--border-color);
            padding: 8px;
            background: var(--bg-secondary);
        }
        
        .table-result tr:nth-child(even) td {
            background: var(--bg-accent);
        }
        
        .concept-box {
            background: var(--bg-accent);
            border: 2px solid var(--ocu-cyan);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .diagram-box {
            background: white;
            border: 2px solid var(--border-color);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        [data-theme="dark"] .diagram-box {
            background: var(--bg-secondary);
        }
    </style>
</head>
<body>
    <!-- Theme toggle will be automatically added by JavaScript -->
    
    <div class="presentation-container">
        <!-- Timer display for activities -->
        <div class="timer-display" id="timer-display">
            <span id="timer-text">Advanced SQL
                 <button class="home"><a href="../../index.html">Home</a></button>
            </span>
        </div>

        <!-- Slide 1: Title -->
        <div class="slide active">
            <h1>Advanced SQL</h1>
            <h2>Subqueries, JOINs, and Set Operations <span class="emoji">üîß</span></h2>
            <p style="font-size: 1.5em; margin-top: 40px;">CSCI 3503 - Database Design</p>
            <p style="font-size: 1.3em;">Week 4, Lecture 8</p>
            <p style="margin-top: auto; font-style: italic;">Mastering complex database queries!</p>
            <p style="font-size: 0.9em; margin-top: 20px;">Instructor: Bobby Reed</p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h1>Today's Learning Objectives</h1>
            <ul style="font-size: 1.4em; line-height: 2;">
                <li>üéØ Master advanced JOIN operations (LEFT, RIGHT, FULL OUTER)</li>
                <li>üéØ Write and understand nested subqueries</li>
                <li>üéØ Use EXISTS, NOT EXISTS for powerful filtering</li>
                <li>üéØ Apply ANY, ALL, and SOME operators effectively</li>
                <li>üéØ Combine queries with set operations</li>
                <li>üéØ Optimize complex queries for performance</li>
            </ul>
        </div>

        <!-- Slide 3: Review - Basic JOINs -->
        <div class="slide">
            <h1>Quick Review: INNER JOIN</h1>
            <p>Before diving into advanced JOINs, let's review the basic INNER JOIN:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find all properties and their managing staff</span><br>
                <span class="sql-keyword">SELECT</span> p.propertyNo, p.street, s.fName, s.lName<br>
                <span class="sql-keyword">FROM</span> PropertyForRent p<br>
                <span class="sql-keyword">INNER JOIN</span> Staff s <span class="sql-keyword">ON</span> p.staffNo = s.staffNo;
            </div>
            
            <div class="concept-box">
                <strong>Remember:</strong> INNER JOIN returns only matching rows from both tables.
                <br>If a property has no staff assigned, or staff manages no properties, they won't appear!
            </div>
        </div>

        <!-- Slide 4: LEFT OUTER JOIN -->
        <div class="slide">
            <h1>LEFT OUTER JOIN</h1>
            <p>Includes ALL rows from the LEFT table, even without matches:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- List all branches and their properties (including branches with no properties)</span><br>
                <span class="sql-keyword">SELECT</span> b.*, p.*<br>
                <span class="sql-keyword">FROM</span> Branch b<br>
                <span class="sql-keyword">LEFT JOIN</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">ON</span> b.city = p.city;
            </div>
            
            <table class="table-result">
                <tr>
                    <th>branchNo</th>
                    <th>bCity</th>
                    <th>propertyNo</th>
                    <th>pCity</th>
                </tr>
                <tr>
                    <td>B003</td>
                    <td>Glasgow</td>
                    <td>PG4</td>
                    <td>Glasgow</td>
                </tr>
                <tr>
                    <td>B004</td>
                    <td>Bristol</td>
                    <td>NULL</td>
                    <td>NULL</td>
                </tr>
                <tr>
                    <td>B002</td>
                    <td>London</td>
                    <td>PL94</td>
                    <td>London</td>
                </tr>
            </table>
            
            <div class="tip-box">
                <strong>Key Point:</strong> NULL values appear for the right table when no match exists.
            </div>
        </div>

        <!-- Slide 5: RIGHT OUTER JOIN -->
        <div class="slide">
            <h1>RIGHT OUTER JOIN</h1>
            <p>Includes ALL rows from the RIGHT table, even without matches:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- List all properties and their branches (including unassigned properties)</span><br>
                <span class="sql-keyword">SELECT</span> b.*, p.*<br>
                <span class="sql-keyword">FROM</span> Branch b<br>
                <span class="sql-keyword">RIGHT JOIN</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">ON</span> b.city = p.city;
            </div>
            
            <table class="table-result">
                <tr>
                    <th>branchNo</th>
                    <th>bCity</th>
                    <th>propertyNo</th>
                    <th>pCity</th>
                </tr>
                <tr>
                    <td>NULL</td>
                    <td>NULL</td>
                    <td>PA14</td>
                    <td>Aberdeen</td>
                </tr>
                <tr>
                    <td>B003</td>
                    <td>Glasgow</td>
                    <td>PG4</td>
                    <td>Glasgow</td>
                </tr>
                <tr>
                    <td>B002</td>
                    <td>London</td>
                    <td>PL94</td>
                    <td>London</td>
                </tr>
            </table>
            
            <div class="demo-box">
                <strong>Pro Tip:</strong> RIGHT JOIN can always be rewritten as LEFT JOIN by swapping table order!
            </div>
        </div>

        <!-- Slide 6: FULL OUTER JOIN -->
        <div class="slide">
            <h1>FULL OUTER JOIN</h1>
            <p>Combines LEFT and RIGHT JOINs - includes ALL rows from BOTH tables:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- List all branches and properties, showing unmatched from both</span><br>
                <span class="sql-keyword">SELECT</span> b.branchNo, b.city <span class="sql-keyword">AS</span> branch_city,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.propertyNo, p.city <span class="sql-keyword">AS</span> prop_city<br>
                <span class="sql-keyword">FROM</span> Branch b<br>
                <span class="sql-keyword">FULL OUTER JOIN</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">ON</span> b.city = p.city;
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Note:</strong> Not all databases support FULL OUTER JOIN (MySQL doesn't).
                You can simulate it using UNION of LEFT and RIGHT JOINs.
            </div>
        </div>

        <!-- Slide 7: Introduction to Subqueries -->
        <div class="slide">
            <h1>Introduction to Subqueries</h1>
            <p>A query within a query - incredibly powerful for complex logic!</p>
            
            <div class="concept-box">
                <h3>Types of Subqueries:</h3>
                <ul>
                    <li><strong>Scalar:</strong> Returns a single value</li>
                    <li><strong>Row:</strong> Returns a single row</li>
                    <li><strong>Table:</strong> Returns multiple rows and columns</li>
                    <li><strong>Correlated:</strong> References outer query columns</li>
                </ul>
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Simple scalar subquery</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, position<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> branchNo = (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> branchNo<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Branch<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> street = <span class="sql-string">'163 Main St'</span><br>
                );
            </div>
        </div>

        <!-- Slide 8: Subquery with Aggregate -->
        <div class="slide">
            <h1>Subqueries with Aggregates</h1>
            <p>Perfect for comparisons against calculated values:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff earning more than average</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, salary,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salary - (<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(salary) <span class="sql-keyword">FROM</span> Staff) <span class="sql-keyword">AS</span> above_avg<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> salary > (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(salary)<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                );
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Common Mistake:</strong> You CANNOT write: WHERE salary > AVG(salary)
                <br>Aggregate functions need GROUP BY or subqueries!
            </div>
        </div>

        <!-- Slide 9: IN Operator with Subqueries -->
        <div class="slide">
            <h1>Using IN with Subqueries</h1>
            <p>Check if a value exists in a subquery result set:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Nested subquery: Find properties managed by staff at '163 Main St'</span><br>
                <span class="sql-keyword">SELECT</span> propertyNo, street, city, rent<br>
                <span class="sql-keyword">FROM</span> PropertyForRent<br>
                <span class="sql-keyword">WHERE</span> staffNo <span class="sql-keyword">IN</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> staffNo<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> branchNo <span class="sql-keyword">IN</span> (<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-keyword">SELECT</span> branchNo<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-keyword">FROM</span> Branch<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-keyword">WHERE</span> street = <span class="sql-string">'163 Main St'</span><br>
                &nbsp;&nbsp;)<br>
                );
            </div>
            
            <div class="tip-box">
                <strong>Performance Tip:</strong> IN is great for small result sets. 
                For large sets, consider EXISTS instead.
            </div>
        </div>

        <!-- Slide 10: Activity 1 - JOIN Practice -->
        <div class="slide">
            <h1>Activity 1: JOIN Challenge <span class="emoji">üíª</span></h1>
            <div class="activity-box">
                <h3>15-Minute Exercise</h3>
                <p>Using our property rental database, write queries to:</p>
                <ol>
                    <li>List ALL staff members and the properties they manage (if any)</li>
                    <li>Show ALL properties and their assigned staff (if any)</li>
                    <li>Find branches that have NO properties in their city</li>
                    <li>Identify staff members who manage NO properties</li>
                </ol>
                <p style="margin-top: 20px;"><strong>Hint:</strong> Think about which JOIN type preserves unmatched rows!</p>
            </div>
            <button data-timer="15">Start 15-Minute Timer</button>
        </div>

        <!-- Slide 11: ANY and ALL Operators -->
        <div class="slide">
            <h1>ANY and ALL Operators</h1>
            <p>Compare a value against a set of values from a subquery:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff earning more than ANY staff at branch B003</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, salary<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> salary > <span class="sql-keyword">ANY</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> salary<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> branchNo = <span class="sql-string">'B003'</span><br>
                );
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff earning more than ALL staff at branch B003</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, salary<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> salary > <span class="sql-keyword">ALL</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> salary<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> branchNo = <span class="sql-string">'B003'</span><br>
                );
            </div>
            
            <div class="concept-box">
                <strong>Remember:</strong>
                <ul>
                    <li>ANY: At least one value satisfies the condition</li>
                    <li>ALL: Every value must satisfy the condition</li>
                    <li>SOME: Synonym for ANY</li>
                    <li>Empty subquery: ALL returns TRUE, ANY returns FALSE</li>
                </ul>
            </div>
        </div>

        <!-- Slide 12: EXISTS and NOT EXISTS -->
        <div class="slide">
            <h1>EXISTS and NOT EXISTS</h1>
            <p>Check for the existence of rows - returns TRUE/FALSE only:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff who manage at least one property</span><br>
                <span class="sql-keyword">SELECT</span> s.staffNo, s.fName, s.lName<br>
                <span class="sql-keyword">FROM</span> Staff s<br>
                <span class="sql-keyword">WHERE</span> <span class="sql-keyword">EXISTS</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> *<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> p.staffNo = s.staffNo<br>
                );
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff who manage NO properties</span><br>
                <span class="sql-keyword">SELECT</span> s.staffNo, s.fName, s.lName<br>
                <span class="sql-keyword">FROM</span> Staff s<br>
                <span class="sql-keyword">WHERE</span> <span class="sql-keyword">NOT EXISTS</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> *<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> p.staffNo = s.staffNo<br>
                );
            </div>
            
            <div class="tip-box">
                <strong>Performance:</strong> EXISTS often faster than IN for large datasets - 
                it stops searching once it finds the first match!
            </div>
        </div>

        <!-- Slide 13: Correlated Subqueries -->
        <div class="slide">
            <h1>Correlated Subqueries</h1>
            <p>Subqueries that reference the outer query - executed for each row:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find properties with rent higher than average for their city</span><br>
                <span class="sql-keyword">SELECT</span> p1.propertyNo, p1.city, p1.rent<br>
                <span class="sql-keyword">FROM</span> PropertyForRent p1<br>
                <span class="sql-keyword">WHERE</span> p1.rent > (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(p2.rent)<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> PropertyForRent p2<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> p2.city = p1.city  <span class="sql-comment">-- References outer query!</span><br>
                );
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Performance Warning:</strong> Correlated subqueries run once per row 
                in the outer query. Can be slow on large tables!
            </div>
        </div>

        <!-- Slide 14: Set Operations Overview -->
        <div class="slide">
            <h1>Set Operations</h1>
            <p>Combine results from multiple queries:</p>
            
            <div class="concept-box">
                <h3>SQL Set Operations:</h3>
                <ul>
                    <li><strong>UNION:</strong> All rows from both queries (removes duplicates)</li>
                    <li><strong>UNION ALL:</strong> All rows including duplicates</li>
                    <li><strong>INTERSECT:</strong> Only rows in both queries</li>
                    <li><strong>EXCEPT/MINUS:</strong> Rows in first but not second query</li>
                </ul>
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Cities with both branches and properties</span><br>
                <span class="sql-keyword">SELECT</span> city <span class="sql-keyword">FROM</span> Branch<br>
                <span class="sql-keyword">INTERSECT</span><br>
                <span class="sql-keyword">SELECT</span> city <span class="sql-keyword">FROM</span> PropertyForRent;
            </div>
            
            <div class="tip-box">
                <strong>Requirement:</strong> Queries must be union-compatible 
                (same number of columns, compatible data types)
            </div>
        </div>

        <!-- Slide 15: Complex Query Example -->
        <div class="slide">
            <h1>Putting It All Together</h1>
            <p>A complex real-world query combining multiple concepts:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find top-performing staff: manage > 2 properties AND earn above branch average</span><br>
                <span class="sql-keyword">SELECT</span> s.staffNo, s.fName, s.lName, s.salary,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(p.propertyNo) <span class="sql-keyword">AS</span> properties_managed<br>
                <span class="sql-keyword">FROM</span> Staff s<br>
                <span class="sql-keyword">LEFT JOIN</span> PropertyForRent p <span class="sql-keyword">ON</span> s.staffNo = p.staffNo<br>
                <span class="sql-keyword">WHERE</span> s.salary > (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(s2.salary)<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff s2<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> s2.branchNo = s.branchNo<br>
                )<br>
                <span class="sql-keyword">GROUP BY</span> s.staffNo, s.fName, s.lName, s.salary<br>
                <span class="sql-keyword">HAVING</span> <span class="sql-function">COUNT</span>(p.propertyNo) > <span class="sql-number">2</span><br>
                <span class="sql-keyword">ORDER BY</span> properties_managed <span class="sql-keyword">DESC</span>, s.salary <span class="sql-keyword">DESC</span>;
            </div>
        </div>

        <!-- Slide 16: Activity 2 - Subquery Challenge -->
        <div class="slide">
            <h1>Activity 2: Subquery Master <span class="emoji">üß©</span></h1>
            <div class="activity-box">
                <h3>20-Minute Challenge</h3>
                <p>Write queries using subqueries to find:</p>
                <ol>
                    <li>Properties with rent higher than the overall average</li>
                    <li>Staff who earn more than ALL managers</li>
                    <li>Branches where EVERY staff member earns > $15,000</li>
                    <li>Cities that have properties but NO branches</li>
                    <li>The branch with the highest total staff salaries</li>
                </ol>
                <p style="margin-top: 20px;"><strong>Bonus:</strong> Rewrite query #4 using both EXISTS and IN approaches!</p>
            </div>
            <button data-timer="20">Start 20-Minute Timer</button>
        </div>

        <!-- Slide 17: Query Optimization Tips -->
        <div class="slide">
            <h1>Query Optimization Best Practices</h1>
            
            <div class="comparison-table">
                <div class="comparison-card good">
                    <h3>‚úÖ DO</h3>
                    <ul>
                        <li>Use EXISTS for existence checks</li>
                        <li>Index foreign key columns</li>
                        <li>Filter early with WHERE</li>
                        <li>Use appropriate JOIN types</li>
                        <li>Consider query execution order</li>
                    </ul>
                </div>
                <div class="comparison-card bad">
                    <h3>‚ùå AVOID</h3>
                    <ul>
                        <li>SELECT * in production</li>
                        <li>Unnecessary nested subqueries</li>
                        <li>Correlated subqueries on large tables</li>
                        <li>DISTINCT when not needed</li>
                        <li>Functions in WHERE clauses</li>
                    </ul>
                </div>
            </div>
            
            <div class="demo-box">
                <strong>Pro Tip:</strong> Use EXPLAIN PLAN to understand how your database executes queries!
            </div>
        </div>

        <!-- Slide 18: Common Pitfalls -->
        <div class="slide">
            <h1>Common Mistakes to Avoid</h1>
            
            <div class="warning-box">
                <h3>üö´ Pitfall #1: NULL Handling</h3>
                <p>NULLs in subqueries can cause unexpected results:</p>
                <code>WHERE column NOT IN (subquery)</code>
                <p>Returns NO rows if subquery contains NULL!</p>
            </div>
            
            <div class="warning-box">
                <h3>üö´ Pitfall #2: Subquery Returns Multiple Rows</h3>
                <p>Using = with a multi-row subquery causes an error.</p>
                <p>Solution: Use IN, ANY, or ALL instead.</p>
            </div>
            
            <div class="warning-box">
                <h3>üö´ Pitfall #3: Forgetting Table Aliases</h3>
                <p>In correlated subqueries, always use clear aliases to avoid ambiguity.</p>
            </div>
        </div>

        <!-- Slide 19: Real-World Application -->
        <div class="slide">
            <h1>Real-World Scenario</h1>
            <p>Let's solve a business problem using advanced SQL:</p>
            
            <div class="demo-box">
                <h3>Business Requirement:</h3>
                <p>"Find underperforming branches: those with below-average property count 
                   and total staff salary below $50,000"</p>
            </div>
            
            <div class="sql-example">
                <span class="sql-keyword">WITH</span> BranchStats <span class="sql-keyword">AS</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> b.branchNo,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(<span class="sql-keyword">DISTINCT</span> p.propertyNo) <span class="sql-keyword">AS</span> prop_count,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">SUM</span>(s.salary) <span class="sql-keyword">AS</span> total_salary<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Branch b<br>
                &nbsp;&nbsp;<span class="sql-keyword">LEFT JOIN</span> PropertyForRent p <span class="sql-keyword">ON</span> b.city = p.city<br>
                &nbsp;&nbsp;<span class="sql-keyword">LEFT JOIN</span> Staff s <span class="sql-keyword">ON</span> b.branchNo = s.branchNo<br>
                &nbsp;&nbsp;<span class="sql-keyword">GROUP BY</span> b.branchNo<br>
                )<br>
                <span class="sql-keyword">SELECT</span> * <span class="sql-keyword">FROM</span> BranchStats<br>
                <span class="sql-keyword">WHERE</span> prop_count < (<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(prop_count) <span class="sql-keyword">FROM</span> BranchStats)<br>
                &nbsp;&nbsp;<span class="sql-keyword">AND</span> total_salary < <span class="sql-number">50000</span>;
            </div>
        </div>

        <!-- Slide 20: Activity 3 - Integration -->
        <div class="slide">
            <h1>Activity 3: Integration Challenge <span class="emoji">üöÄ</span></h1>
            <div class="activity-box">
                <h3>25-Minute Complex Query Exercise</h3>
                <p><strong>Scenario:</strong> Management needs a comprehensive report!</p>
                <p>Create a query that shows:</p>
                <ul>
                    <li>All branches with their city</li>
                    <li>Count of properties in each city</li>
                    <li>Average property rent for the city</li>
                    <li>Number of staff at each branch</li>
                    <li>Whether the branch is "High Performing" (>3 properties AND >2 staff)</li>
                </ul>
                <p style="margin-top: 20px;"><strong>Requirements:</strong></p>
                <ul>
                    <li>Use at least one OUTER JOIN</li>
                    <li>Include a correlated subquery</li>
                    <li>Use CASE statement for performance classification</li>
                </ul>
            </div>
            <button data-timer="25">Start 25-Minute Timer</button>
        </div>

        <!-- IN-CLASS EXERCISES -->

        <!-- Slide 21: Exercise Overview -->
        <div class="slide">
            <h1>In-Class Exercises <span class="emoji">üèóÔ∏è</span></h1>
            <h2>Multi-JOIN & Aggregation Practice</h2>

            <div class="demo-box">
                <h3>Exercise Overview</h3>
                <p style="font-size: 1.2em;">Today, you'll practice writing complex SQL queries involving three-table JOINs and advanced aggregation with GROUP BY and HAVING clauses.</p>
            </div>

            <div class="activity-box">
                <h3>Learning Objectives</h3>
                <ul style="font-size: 1.15em;">
                    <li>‚úÖ Write multi-table INNER JOIN queries</li>
                    <li>‚úÖ Use table aliases for readability</li>
                    <li>‚úÖ Apply COUNT and AVG with GROUP BY</li>
                    <li>‚úÖ Filter aggregated results with HAVING</li>
                </ul>
            </div>
        </div>

        <!-- Slide 22: Exercise 1 -->
        <div class="slide">
            <h1>Exercise 1: Three-Table JOIN</h1>
            <h2>Individual Exercise (20 minutes)</h2>

            <div class="activity-box">
                <h3>Your Task:</h3>
                <p style="font-size: 1.1em;">Write an SQL query that requires a <strong>THREE-TABLE INNER JOIN</strong> and uses table aliases for readability.</p>
            </div>

            <div class="demo-box">
                <h3>Query Goal:</h3>
                <p style="font-size: 1.15em;">"Find the instructors who teach courses taken by student 'S10001', along with the course names and grades."</p>
            </div>

            <div class="demo-box">
                <h3>Schema:</h3>
                <div style="font-family: monospace; font-size: 0.95em;">
                    <strong>Student</strong>(studentID, firstName, lastName, email, major, GPA)<br>
                    <strong>Course</strong>(courseID, courseName, department, credits, instructorName)<br>
                    <strong>Enrollment</strong>(studentID, courseID, semester, grade, enrollDate)
                </div>
            </div>

            <div class="tip-box">
                <h3>Requirements:</h3>
                <ul style="font-size: 1.05em;">
                    <li>Join all three tables: Student, Course, and Enrollment</li>
                    <li>Use table aliases (e.g., s, c, e) for readability</li>
                    <li>Select: studentID, student name, course name, instructor name, grade</li>
                    <li>Filter for student 'S10001'</li>
                </ul>
            </div>

            <button data-timer="20">Start 20-Minute Timer</button>
        </div>

        <!-- Slide 23: Understanding Exercise 1 -->
        <div class="slide">
            <h1>Understanding: Three-Table JOINs</h1>

            <div class="tip-box">
                <h3>Solution:</h3>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;s.studentID,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;s.firstName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;s.lastName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;c.courseName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;c.instructorName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;e.grade<br>
                <span class="sql-keyword">FROM</span> Student s<br>
                <span class="sql-keyword">INNER JOIN</span> Enrollment e <span class="sql-keyword">ON</span> s.studentID = e.studentID<br>
                <span class="sql-keyword">INNER JOIN</span> Course c <span class="sql-keyword">ON</span> e.courseID = c.courseID<br>
                <span class="sql-keyword">WHERE</span> s.studentID = <span class="sql-string">'S10001'</span>;
            </div>

            <div class="demo-box">
                <h3>Key Insights:</h3>
                <ul style="font-size: 1.05em; line-height: 1.7;">
                    <li><strong>JOIN Order:</strong> Start with Student, join Enrollment (linking table), then Course</li>
                    <li><strong>Table Aliases:</strong> s, e, c make the query much more readable</li>
                    <li><strong>ON Conditions:</strong> Connect tables via foreign keys (studentID and courseID)</li>
                    <li><strong>INNER JOIN:</strong> Only returns rows where matches exist in all three tables</li>
                </ul>
            </div>
        </div>

        <!-- Slide 24: Understanding Exercise 1 (continued) -->
        <div class="slide">
            <h1>Understanding: JOIN Execution Flow</h1>

            <div class="concept-box">
                <h3>How the Database Processes This Query:</h3>
                <ol style="font-size: 1.05em; line-height: 1.8;">
                    <li><strong>Step 1:</strong> Filter Student table WHERE studentID = 'S10001'</li>
                    <li><strong>Step 2:</strong> JOIN with Enrollment using matching studentID values</li>
                    <li><strong>Step 3:</strong> JOIN result with Course using matching courseID values</li>
                    <li><strong>Step 4:</strong> Project (SELECT) the requested columns</li>
                </ol>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Sample Result Set:</h3>
                <table class="table-result">
                    <tr>
                        <th>studentID</th>
                        <th>firstName</th>
                        <th>lastName</th>
                        <th>courseName</th>
                        <th>instructorName</th>
                        <th>grade</th>
                    </tr>
                    <tr>
                        <td>S10001</td>
                        <td>John</td>
                        <td>Smith</td>
                        <td>Database Design</td>
                        <td>Dr. Reed</td>
                        <td>A</td>
                    </tr>
                    <tr>
                        <td>S10001</td>
                        <td>John</td>
                        <td>Smith</td>
                        <td>Data Structures</td>
                        <td>Dr. Johnson</td>
                        <td>B+</td>
                    </tr>
                    <tr>
                        <td>S10001</td>
                        <td>John</td>
                        <td>Smith</td>
                        <td>Algorithms</td>
                        <td>Dr. Martinez</td>
                        <td>A-</td>
                    </tr>
                </table>
            </div>

            <div class="tip-box">
                <strong>Pro Tip:</strong> Using aliases (s, e, c) is considered best practice for multi-table queries!
            </div>
        </div>

        <!-- Slide 25: Exercise 2 -->
        <div class="slide">
            <h1>Exercise 2: Aggregation & Grouping</h1>
            <h2>Individual Exercise (20 minutes)</h2>

            <div class="activity-box">
                <h3>Your Task:</h3>
                <p style="font-size: 1.1em;">Write SQL queries using <strong>COUNT and AVG</strong> with GROUP BY and a HAVING clause to answer two analytical questions about department data.</p>
            </div>

            <div class="demo-box">
                <h3>Question 1:</h3>
                <p>"Find each department's total number of courses and average credits per course. Only include departments offering more than 2 courses."</p>
            </div>

            <div class="demo-box">
                <h3>Question 2:</h3>
                <p>"Find each department's average course credits. Only include departments where the average credits is greater than or equal to 3.0."</p>
            </div>

            <div class="tip-box">
                <h3>Schema Reminder:</h3>
                <p style="font-family: monospace;">Course(courseID, courseName, department, credits, instructorName)</p>
            </div>

            <button data-timer="20">Start 20-Minute Timer</button>
        </div>

        <!-- Slide 26: Understanding Exercise 2 -->
        <div class="slide">
            <h1>Understanding: Aggregation Solutions</h1>

            <div class="tip-box">
                <h3>Solutions:</h3>
            </div>

            <div class="sql-example" style="font-size: 0.9em;">
                <span class="sql-comment">-- Question 1: Count and avg with HAVING for course count</span><br>
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;department,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(*) <span class="sql-keyword">AS</span> total_courses,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">AVG</span>(credits) <span class="sql-keyword">AS</span> avg_credits<br>
                <span class="sql-keyword">FROM</span> Course<br>
                <span class="sql-keyword">GROUP BY</span> department<br>
                <span class="sql-keyword">HAVING</span> <span class="sql-function">COUNT</span>(*) > 2;<br><br>

                <span class="sql-comment">-- Question 2: Avg with HAVING for credit threshold</span><br>
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;department,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">AVG</span>(credits) <span class="sql-keyword">AS</span> avg_credits<br>
                <span class="sql-keyword">FROM</span> Course<br>
                <span class="sql-keyword">GROUP BY</span> department<br>
                <span class="sql-keyword">HAVING</span> <span class="sql-function">AVG</span>(credits) >= 3.0;
            </div>
        </div>

        <!-- Slide 27: Understanding Exercise 2 (continued) -->
        <div class="slide">
            <h1>Understanding: GROUP BY vs HAVING</h1>

            <div class="concept-box">
                <h3>The Difference:</h3>
                <table class="table-result" style="font-size: 0.95em;">
                    <tr>
                        <th>Clause</th>
                        <th>Purpose</th>
                        <th>When It's Applied</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td><strong>WHERE</strong></td>
                        <td>Filter individual rows</td>
                        <td>Before grouping</td>
                        <td>WHERE credits > 3</td>
                    </tr>
                    <tr>
                        <td><strong>GROUP BY</strong></td>
                        <td>Organize rows into groups</td>
                        <td>After WHERE filtering</td>
                        <td>GROUP BY department</td>
                    </tr>
                    <tr>
                        <td><strong>HAVING</strong></td>
                        <td>Filter groups</td>
                        <td>After grouping</td>
                        <td>HAVING COUNT(*) > 2</td>
                    </tr>
                </table>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Sample Result (Question 1):</h3>
                <table class="table-result">
                    <tr>
                        <th>department</th>
                        <th>total_courses</th>
                        <th>avg_credits</th>
                    </tr>
                    <tr>
                        <td>Computer Science</td>
                        <td>5</td>
                        <td>3.4</td>
                    </tr>
                    <tr>
                        <td>Mathematics</td>
                        <td>4</td>
                        <td>3.25</td>
                    </tr>
                    <tr>
                        <td>Engineering</td>
                        <td>3</td>
                        <td>3.67</td>
                    </tr>
                </table>
            </div>

            <div class="warning-box">
                <strong>Important:</strong> You CANNOT use WHERE to filter on aggregated values. That's what HAVING is for!
            </div>
        </div>

        <!-- HOMEWORK SECTION -->

        <!-- Slide 28: Homework Overview -->
        <div class="slide">
            <h1>Homework Assignment <span class="emoji">üìù</span></h1>
            <h2>Week 8: OUTER JOINs & ROLLUP</h2>

            <div class="demo-box">
                <h3>Assignment Overview</h3>
                <p style="font-size: 1.15em;">This week's homework extends today's exercises by exploring OUTER JOIN syntax and advanced aggregation with ROLLUP/CUBE clauses for hierarchical reporting.</p>
            </div>

            <div class="tip-box">
                <h3>Due Date: <strong>Before Class Next Week</strong></h3>
                <p>Submit via Canvas as a single PDF</p>
            </div>

            <div class="activity-box">
                <h3>Components:</h3>
                <ol style="font-size: 1.15em; line-height: 1.8;">
                    <li><strong>Homework Extension 1:</strong> INNER to OUTER JOIN Conversion (50 points)</li>
                    <li><strong>Homework Extension 2:</strong> ROLLUP/CUBE Report (50 points)</li>
                </ol>
                <p style="margin-top: 15px; font-size: 1.1em;"><strong>Total: 100 points</strong></p>
            </div>
        </div>

        <!-- Slide 29: Homework Extension 1 -->
        <div class="slide">
            <h1>Homework Extension 1: OUTER JOIN Conversion</h1>
            <h2>Building on Exercise 1</h2>

            <div class="activity-box">
                <h3>Task:</h3>
                <p style="font-size: 1.15em;">Rewrite the three-table JOIN query from Exercise 1 using a combination of <strong>LEFT or RIGHT OUTER JOIN</strong> syntax instead of INNER JOIN.</p>
            </div>

            <div class="demo-box">
                <h3>Original Query (INNER JOIN):</h3>
                <div class="sql-example" style="font-size: 0.8em;">
                    <span class="sql-keyword">SELECT</span> s.studentID, s.firstName, s.lastName,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.courseName, c.instructorName, e.grade<br>
                    <span class="sql-keyword">FROM</span> Student s<br>
                    <span class="sql-keyword">INNER JOIN</span> Enrollment e <span class="sql-keyword">ON</span> s.studentID = e.studentID<br>
                    <span class="sql-keyword">INNER JOIN</span> Course c <span class="sql-keyword">ON</span> e.courseID = c.courseID<br>
                    <span class="sql-keyword">WHERE</span> s.studentID = <span class="sql-string">'S10001'</span>;
                </div>
            </div>

            <div class="demo-box">
                <h3>Requirements:</h3>
                <ol style="font-size: 1.05em; line-height: 1.8;">
                    <li><strong>Rewrite using LEFT/RIGHT JOIN:</strong>
                        <ul style="margin-top: 8px;">
                            <li>Replace at least one INNER JOIN with LEFT or RIGHT JOIN</li>
                            <li>Ensure the query still returns the same results for student 'S10001'</li>
                        </ul>
                    </li>
                    <li><strong>Write explanation (150-200 words):</strong>
                        <ul style="margin-top: 8px;">
                            <li>How does the result set differ with OUTER JOIN?</li>
                            <li>In what scenario (with incomplete data) would OUTER JOIN show different results?</li>
                            <li>Provide a specific example of when you'd want to see NULL values</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>

        <!-- Slide 30: OUTER JOIN Guidance -->
        <div class="slide">
            <h1>Understanding OUTER JOINs</h1>

            <div class="concept-box">
                <h3>Hint for Homework Extension 1:</h3>
                <p style="font-size: 1.05em;">Consider what happens if a student is enrolled (in Student table) but has NO enrollment records yet. An INNER JOIN would exclude them, but a LEFT JOIN would include them with NULL values for course data.</p>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Example Conversion:</h3>
                <span class="sql-keyword">SELECT</span> s.studentID, s.firstName, s.lastName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.courseName, c.instructorName, e.grade<br>
                <span class="sql-keyword">FROM</span> Student s<br>
                <span class="sql-keyword">LEFT JOIN</span> Enrollment e <span class="sql-keyword">ON</span> s.studentID = e.studentID<br>
                <span class="sql-keyword">LEFT JOIN</span> Course c <span class="sql-keyword">ON</span> e.courseID = c.courseID<br>
                <span class="sql-keyword">WHERE</span> s.studentID = <span class="sql-string">'S10001'</span>;
            </div>

            <div class="tip-box">
                <h3>Difference in Results:</h3>
                <p>If student 'S10001' exists but has zero enrollments:</p>
                <ul style="font-size: 1.05em;">
                    <li><strong>INNER JOIN:</strong> Returns 0 rows</li>
                    <li><strong>LEFT JOIN:</strong> Returns 1 row with NULLs for courseName, instructorName, grade</li>
                </ul>
            </div>
        </div>

        <!-- Slide 31: Homework Extension 2 -->
        <div class="slide">
            <h1>Homework Extension 2: ROLLUP Report</h1>
            <h2>Building on Exercise 2</h2>

            <div class="activity-box">
                <h3>Task:</h3>
                <p style="font-size: 1.15em;">Write a single SQL query that uses the <strong>ROLLUP clause</strong> to generate a report that includes department-level aggregations PLUS the overall total.</p>
            </div>

            <div class="demo-box">
                <h3>Report Requirements:</h3>
                <p>Your query should produce a result set showing:</p>
                <ol style="font-size: 1.05em; line-height: 1.8;">
                    <li>Each department's total course count and average credits</li>
                    <li>A grand total row showing overall course count and average credits across ALL departments</li>
                </ol>
            </div>

            <div class="warning-box">
                <h3>‚ö†Ô∏è Database Note:</h3>
                <p>ROLLUP syntax varies by database:</p>
                <ul style="font-size: 0.95em;">
                    <li><strong>MySQL/PostgreSQL:</strong> GROUP BY department WITH ROLLUP</li>
                    <li><strong>SQL Server:</strong> GROUP BY ROLLUP(department)</li>
                    <li><strong>Oracle:</strong> GROUP BY ROLLUP(department)</li>
                </ul>
                <p style="margin-top: 10px;">Use the syntax appropriate for your database!</p>
            </div>
        </div>

        <!-- Slide 32: ROLLUP Example -->
        <div class="slide">
            <h1>Understanding ROLLUP</h1>

            <div class="sql-example" style="font-size: 0.9em;">
                <h3>ROLLUP Query Example (MySQL):</h3>
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;department,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(*) <span class="sql-keyword">AS</span> total_courses,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">AVG</span>(credits) <span class="sql-keyword">AS</span> avg_credits<br>
                <span class="sql-keyword">FROM</span> Course<br>
                <span class="sql-keyword">GROUP BY</span> department <span class="sql-keyword">WITH ROLLUP</span>;
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Expected Result Set:</h3>
                <table class="table-result">
                    <tr>
                        <th>department</th>
                        <th>total_courses</th>
                        <th>avg_credits</th>
                    </tr>
                    <tr>
                        <td>Computer Science</td>
                        <td>5</td>
                        <td>3.40</td>
                    </tr>
                    <tr>
                        <td>Mathematics</td>
                        <td>4</td>
                        <td>3.25</td>
                    </tr>
                    <tr>
                        <td>Engineering</td>
                        <td>3</td>
                        <td>3.67</td>
                    </tr>
                    <tr style="background: #ffffcc;">
                        <td><strong>NULL (Grand Total)</strong></td>
                        <td><strong>12</strong></td>
                        <td><strong>3.42</strong></td>
                    </tr>
                </table>
            </div>

            <div class="tip-box">
                <strong>Key Point:</strong> The NULL in the department column indicates the grand total row!
            </div>
        </div>

        <!-- Slide 33: CUBE vs ROLLUP -->
        <div class="slide">
            <h1>BONUS: CUBE vs ROLLUP</h1>

            <div class="concept-box">
                <h3>Optional Enhancement (5 bonus points):</h3>
                <p style="font-size: 1.05em;">If your database supports CUBE, write a second query using CUBE instead of ROLLUP and explain the difference in output.</p>
            </div>

            <div class="demo-box">
                <h3>ROLLUP vs CUBE:</h3>
                <table class="table-result" style="font-size: 0.9em;">
                    <tr>
                        <th>Operation</th>
                        <th>What It Does</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>ROLLUP</strong></td>
                        <td>Creates subtotals + grand total in hierarchical order</td>
                        <td>When grouping columns have a natural hierarchy</td>
                    </tr>
                    <tr>
                        <td><strong>CUBE</strong></td>
                        <td>Creates all possible combinations of subtotals</td>
                        <td>When you want to analyze data from all dimensions</td>
                    </tr>
                </table>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>CUBE Example (for multi-column grouping):</h3>
                <span class="sql-keyword">GROUP BY</span> <span class="sql-keyword">CUBE</span>(department, semester)
                <p style="margin-top: 10px;">This would produce:</p>
                <ul style="font-size: 0.95em;">
                    <li>Totals for each (department, semester) combination</li>
                    <li>Totals for each department across all semesters</li>
                    <li>Totals for each semester across all departments</li>
                    <li>Grand total across both dimensions</li>
                </ul>
            </div>
        </div>

        <!-- Slide 34: Submission Requirements -->
        <div class="slide">
            <h1>Submission Requirements <span class="emoji">‚úÖ</span></h1>

            <div class="demo-box">
                <h3>Format:</h3>
                <ul style="font-size: 1.15em; line-height: 1.8;">
                    <li><strong>File:</strong> LastName_FirstName_Week8_Homework.pdf</li>
                    <li><strong>Platform:</strong> Canvas</li>
                    <li><strong>Due:</strong> Before next class</li>
                </ul>
            </div>

            <div class="activity-box">
                <h3>Document Structure:</h3>
                <ol style="font-size: 1.1em; line-height: 1.8;">
                    <li><strong>Cover Page:</strong> Name, date, "Week 8 Homework"</li>
                    <li><strong>Page 2-3:</strong> Extension 1
                        <ul style="margin-top: 8px;">
                            <li>Rewritten OUTER JOIN query</li>
                            <li>Explanation (150-200 words)</li>
                        </ul>
                    </li>
                    <li><strong>Page 4-5:</strong> Extension 2
                        <ul style="margin-top: 8px;">
                            <li>ROLLUP query with results</li>
                            <li>Screenshot or table showing output</li>
                            <li>(Optional) CUBE query for bonus points</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="demo-box">
                <h3>Grading:</h3>
                <table class="table-result" style="font-size: 0.95em;">
                    <tr>
                        <th>Component</th>
                        <th>Points</th>
                        <th>Criteria</th>
                    </tr>
                    <tr>
                        <td><strong>OUTER JOIN</strong></td>
                        <td>50</td>
                        <td>Correct syntax (25), Explanation (20), Example (5)</td>
                    </tr>
                    <tr>
                        <td><strong>ROLLUP Query</strong></td>
                        <td>50</td>
                        <td>Correct syntax (30), Results shown (15), Formatting (5)</td>
                    </tr>
                    <tr>
                        <td><strong>CUBE (Bonus)</strong></td>
                        <td>+5</td>
                        <td>Correct implementation and explanation</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Slide 35: Summary -->
        <div class="slide">
            <h1>Today's Takeaways <span class="emoji">üéì</span></h1>
            <h2>You Can Now:</h2>
            <ul>
                <li>‚úÖ Use LEFT, RIGHT, and FULL OUTER JOINs effectively</li>
                <li>‚úÖ Write scalar, row, and correlated subqueries</li>
                <li>‚úÖ Apply EXISTS/NOT EXISTS for efficient filtering</li>
                <li>‚úÖ Use ANY, ALL, and SOME with subqueries</li>
                <li>‚úÖ Combine queries with set operations</li>
                <li>‚úÖ Optimize complex queries for performance</li>
                <li>‚úÖ Avoid common SQL pitfalls</li>
                <li>‚úÖ Write multi-table INNER JOINs with aliases</li>
                <li>‚úÖ Use COUNT and AVG with GROUP BY and HAVING</li>
            </ul>
            <div class="demo-box">
                <p><strong>Next Lecture:</strong> Database Views and Stored Procedures</p>
                <p><strong>Homework:</strong> OUTER JOIN conversion & ROLLUP query (due next week)</p>
            </div>
        </div>

        <!-- Navigation Controls -->
        <div class="navigation">
            <button id="prevBtn">Previous</button>
            <span class="slide-counter">
                <span id="currentSlide">1</span> / <span id="totalSlides">35</span>
            </span>
            <button id="nextBtn">Next</button>
        </div>
    </div>

    <!-- Shared Presentation JavaScript -->
    <script src="../../js/presentation.js"></script>

    <!-- Lecture-Specific JavaScript -->
    <script>
        // Advanced SQL specific interactions
        document.addEventListener('slidechange', (e) => {
            console.log(`Slide ${e.detail.currentSlide + 1} of ${e.detail.totalSlides}`);
            
            // Add any SQL-specific animations or interactions here
            const currentSlideElement = document.querySelectorAll('.slide')[e.detail.currentSlide];
            
            // Animate SQL examples on slide entry
            const sqlExamples = currentSlideElement.querySelectorAll('.sql-example');
            sqlExamples.forEach((example, index) => {
                example.style.animation = `fadeIn 0.5s ease-in-out ${index * 0.2}s forwards`;
            });
        });
        
        // Add keyboard shortcuts for common SQL keywords
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey) {
                switch(e.key) {
                    case 'S':
                        console.log('SQL Reference: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY');
                        break;
                    case 'J':
                        console.log('JOIN Types: INNER, LEFT, RIGHT, FULL OUTER, CROSS');
                        break;
                    case 'F':
                        console.log('Functions: COUNT, SUM, AVG, MIN, MAX');
                        break;
                }
            }
        });
    </script>
</body>
</html>