<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced SQL - CSCI 5603</title>
    
    <!-- Database Design Presentation Styles with Theme Support -->
    <link rel="stylesheet" href="/styles/presentation.css">
    <link rel="icon" type="image/x-icon" href="/images/favicon.png">
    
    <!-- Import Courier Prime for analog feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=IBM+Plex+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lecture-Specific Styles -->
    <style>
        /* Override font for analog feel */
        body, .slide, h1, h2, h3, p, li {
            font-family: 'Courier Prime', 'IBM Plex Mono', 'Courier New', monospace !important;
        }
        
        /* SQL syntax highlighting classes now in presentation.css */

        .table-result {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
        }
        
        .table-result th {
            background: var(--ocu-true-blue);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 600;
        }
        
        .table-result td {
            border: 1px solid var(--border-color);
            padding: 8px;
            background: var(--bg-secondary);
        }
        
        .table-result tr:nth-child(even) td {
            background: var(--bg-accent);
        }
        
        .concept-box {
            background: var(--bg-accent);
            border: 2px solid var(--ocu-cyan);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .diagram-box {
            background: white;
            border: 2px solid var(--border-color);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        [data-theme="dark"] .diagram-box {
            background: var(--bg-secondary);
        }
    </style>
</head>
<body>
    <!-- Theme toggle will be automatically added by JavaScript -->
    
    <div class="presentation-container">
        <!-- Timer display for activities -->
        <div class="timer-display" id="timer-display">
            <span id="timer-text">Advanced SQL
                 <button class="home"><a href="../../index.html">Home</a></button>
            </span>
        </div>

        <!-- Slide 1: Title -->
        <div class="slide active">
            <h1>Advanced SQL</h1>
            <h2>Subqueries, JOINs, and Set Operations <span class="emoji">üîß</span></h2>
            <p style="font-size: 1.5em; margin-top: 40px;">CSCI 5603 - Database Design</p>
            <p style="font-size: 1.3em;">Week 4, Lecture 8</p>
            <p style="margin-top: auto; font-style: italic;">Mastering complex database queries!</p>
            <p style="font-size: 0.9em; margin-top: 20px;">Instructor: Bobby Reed</p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h1>Today's Learning Objectives</h1>
            <ul style="font-size: 1.4em; line-height: 2;">
                <li>üéØ Master advanced JOIN operations (LEFT, RIGHT, FULL OUTER)</li>
                <li>üéØ Write and understand nested subqueries</li>
                <li>üéØ Use EXISTS, NOT EXISTS for powerful filtering</li>
                <li>üéØ Apply ANY, ALL, and SOME operators effectively</li>
                <li>üéØ Combine queries with set operations</li>
                <li>üéØ Optimize complex queries for performance</li>
            </ul>
        </div>

        <!-- Slide 3: Historical Context -->
        <div class="slide">
            <h1>Historical Context <span class="emoji">üìú</span></h1>
            <h2>The Commercial Database Revolution</h2>

            <div class="concept-box">
                <h3>Early Commercial Successes (Early 1980s)</h3>
                <p style="font-size: 1.15em; line-height: 1.7;">The early 1980s witnessed the rise of commercial SQL databases that transformed the industry. Oracle (founded 1977, shipping Version 2 in 1979) was one of the first to commercialize SQL, followed by Sybase, Informix, and IBM DB2. These systems solidified SQL's dominance in the market and proved that relational databases could meet real-world business needs at scale.</p>
            </div>

            <div class="tip-box">
                <strong>Key Insight:</strong> The success of these early commercial databases demonstrated that Edgar Codd's theoretical relational model could be implemented efficiently and profitably‚Äîtransforming data management from an academic concept to a multi-billion dollar industry.
            </div>
        </div>

        <!-- Slide 4: Review - Basic JOINs -->
        <div class="slide">
            <h1>Quick Review: INNER JOIN</h1>
            <p>Before diving into advanced JOINs, let's review the basic INNER JOIN:</p>

            <div class="sql-example">
                <span class="sql-comment">-- Find all properties and their managing staff</span><br>
                <span class="sql-keyword">SELECT</span> p.propertyNo, p.street, s.fName, s.lName<br>
                <span class="sql-keyword">FROM</span> PropertyForRent p<br>
                <span class="sql-keyword">INNER JOIN</span> Staff s <span class="sql-keyword">ON</span> p.staffNo = s.staffNo;
            </div>

            <div class="concept-box">
                <strong>Remember:</strong> INNER JOIN returns only matching rows from both tables.
                <br>If a property has no staff assigned, or staff manages no properties, they won't appear!
            </div>
        </div>

        <!-- Slide 4: LEFT OUTER JOIN -->
        <div class="slide">
            <h1>LEFT OUTER JOIN</h1>
            <p>Includes ALL rows from the LEFT table, even without matches:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- List all branches and their properties (including branches with no properties)</span><br>
                <span class="sql-keyword">SELECT</span> b.*, p.*<br>
                <span class="sql-keyword">FROM</span> Branch b<br>
                <span class="sql-keyword">LEFT JOIN</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">ON</span> b.city = p.city;
            </div>
            
            <table class="table-result">
                <tr>
                    <th>branchNo</th>
                    <th>bCity</th>
                    <th>propertyNo</th>
                    <th>pCity</th>
                </tr>
                <tr>
                    <td>B003</td>
                    <td>Glasgow</td>
                    <td>PG4</td>
                    <td>Glasgow</td>
                </tr>
                <tr>
                    <td>B004</td>
                    <td>Bristol</td>
                    <td>NULL</td>
                    <td>NULL</td>
                </tr>
                <tr>
                    <td>B002</td>
                    <td>London</td>
                    <td>PL94</td>
                    <td>London</td>
                </tr>
            </table>
            
            <div class="tip-box">
                <strong>Key Point:</strong> NULL values appear for the right table when no match exists.
            </div>
        </div>

        <!-- Slide 5: RIGHT OUTER JOIN -->
        <div class="slide">
            <h1>RIGHT OUTER JOIN</h1>
            <p>Includes ALL rows from the RIGHT table, even without matches:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- List all properties and their branches (including unassigned properties)</span><br>
                <span class="sql-keyword">SELECT</span> b.*, p.*<br>
                <span class="sql-keyword">FROM</span> Branch b<br>
                <span class="sql-keyword">RIGHT JOIN</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">ON</span> b.city = p.city;
            </div>
            
            <table class="table-result">
                <tr>
                    <th>branchNo</th>
                    <th>bCity</th>
                    <th>propertyNo</th>
                    <th>pCity</th>
                </tr>
                <tr>
                    <td>NULL</td>
                    <td>NULL</td>
                    <td>PA14</td>
                    <td>Aberdeen</td>
                </tr>
                <tr>
                    <td>B003</td>
                    <td>Glasgow</td>
                    <td>PG4</td>
                    <td>Glasgow</td>
                </tr>
                <tr>
                    <td>B002</td>
                    <td>London</td>
                    <td>PL94</td>
                    <td>London</td>
                </tr>
            </table>
            
            <div class="demo-box">
                <strong>Pro Tip:</strong> RIGHT JOIN can always be rewritten as LEFT JOIN by swapping table order!
            </div>
        </div>

        <!-- Slide 6: FULL OUTER JOIN -->
        <div class="slide">
            <h1>FULL OUTER JOIN</h1>
            <p>Combines LEFT and RIGHT JOINs - includes ALL rows from BOTH tables:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- List all branches and properties, showing unmatched from both</span><br>
                <span class="sql-keyword">SELECT</span> b.branchNo, b.city <span class="sql-keyword">AS</span> branch_city,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.propertyNo, p.city <span class="sql-keyword">AS</span> prop_city<br>
                <span class="sql-keyword">FROM</span> Branch b<br>
                <span class="sql-keyword">FULL OUTER JOIN</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">ON</span> b.city = p.city;
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Note:</strong> Not all databases support FULL OUTER JOIN (MySQL doesn't).
                You can simulate it using UNION of LEFT and RIGHT JOINs.
            </div>
        </div>

        <!-- Slide 7: Introduction to Subqueries -->
        <div class="slide">
            <h1>Introduction to Subqueries</h1>
            <p>A query within a query - incredibly powerful for complex logic!</p>
            
            <div class="concept-box">
                <h3>Types of Subqueries:</h3>
                <ul>
                    <li><strong>Scalar:</strong> Returns a single value</li>
                    <li><strong>Row:</strong> Returns a single row</li>
                    <li><strong>Table:</strong> Returns multiple rows and columns</li>
                    <li><strong>Correlated:</strong> References outer query columns</li>
                </ul>
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Simple scalar subquery</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, position<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> branchNo = (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> branchNo<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Branch<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> street = <span class="sql-string">'163 Main St'</span><br>
                );
            </div>
        </div>

        <!-- Slide 8: Subquery with Aggregate -->
        <div class="slide">
            <h1>Subqueries with Aggregates</h1>
            <p>Perfect for comparisons against calculated values:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff earning more than average</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, salary,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salary - (<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(salary) <span class="sql-keyword">FROM</span> Staff) <span class="sql-keyword">AS</span> above_avg<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> salary > (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(salary)<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                );
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Common Mistake:</strong> You CANNOT write: WHERE salary > AVG(salary)
                <br>Aggregate functions need GROUP BY or subqueries!
            </div>
        </div>

        <!-- Slide 9: IN Operator with Subqueries -->
        <div class="slide">
            <h1>Using IN with Subqueries</h1>
            <p>Check if a value exists in a subquery result set:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Nested subquery: Find properties managed by staff at '163 Main St'</span><br>
                <span class="sql-keyword">SELECT</span> propertyNo, street, city, rent<br>
                <span class="sql-keyword">FROM</span> PropertyForRent<br>
                <span class="sql-keyword">WHERE</span> staffNo <span class="sql-keyword">IN</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> staffNo<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> branchNo <span class="sql-keyword">IN</span> (<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-keyword">SELECT</span> branchNo<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-keyword">FROM</span> Branch<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-keyword">WHERE</span> street = <span class="sql-string">'163 Main St'</span><br>
                &nbsp;&nbsp;)<br>
                );
            </div>
            
            <div class="tip-box">
                <strong>Performance Tip:</strong> IN is great for small result sets. 
                For large sets, consider EXISTS instead.
            </div>
        </div>

        <!-- Slide 10: Activity 1 - JOIN Practice -->
        <div class="slide">
            <h1>Activity 1: JOIN Challenge <span class="emoji">üíª</span></h1>
            <div class="activity-box">
                <h3>15-Minute Exercise</h3>
                <p>Using our property rental database, write queries to:</p>
                <ol>
                    <li>List ALL staff members and the properties they manage (if any)</li>
                    <li>Show ALL properties and their assigned staff (if any)</li>
                    <li>Find branches that have NO properties in their city</li>
                    <li>Identify staff members who manage NO properties</li>
                </ol>
                <p style="margin-top: 20px;"><strong>Hint:</strong> Think about which JOIN type preserves unmatched rows!</p>
            </div>
            <button data-timer="15">Start 15-Minute Timer</button>
        </div>

        <!-- Slide 11: ANY and ALL Operators -->
        <div class="slide">
            <h1>ANY and ALL Operators</h1>
            <p>Compare a value against a set of values from a subquery:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff earning more than ANY staff at branch B003</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, salary<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> salary > <span class="sql-keyword">ANY</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> salary<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> branchNo = <span class="sql-string">'B003'</span><br>
                );
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff earning more than ALL staff at branch B003</span><br>
                <span class="sql-keyword">SELECT</span> staffNo, fName, lName, salary<br>
                <span class="sql-keyword">FROM</span> Staff<br>
                <span class="sql-keyword">WHERE</span> salary > <span class="sql-keyword">ALL</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> salary<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> branchNo = <span class="sql-string">'B003'</span><br>
                );
            </div>
            
            <div class="concept-box">
                <strong>Remember:</strong>
                <ul>
                    <li>ANY: At least one value satisfies the condition</li>
                    <li>ALL: Every value must satisfy the condition</li>
                    <li>SOME: Synonym for ANY</li>
                    <li>Empty subquery: ALL returns TRUE, ANY returns FALSE</li>
                </ul>
            </div>
        </div>

        <!-- Slide 12: EXISTS and NOT EXISTS -->
        <div class="slide">
            <h1>EXISTS and NOT EXISTS</h1>
            <p>Check for the existence of rows - returns TRUE/FALSE only:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff who manage at least one property</span><br>
                <span class="sql-keyword">SELECT</span> s.staffNo, s.fName, s.lName<br>
                <span class="sql-keyword">FROM</span> Staff s<br>
                <span class="sql-keyword">WHERE</span> <span class="sql-keyword">EXISTS</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> *<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> p.staffNo = s.staffNo<br>
                );
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find staff who manage NO properties</span><br>
                <span class="sql-keyword">SELECT</span> s.staffNo, s.fName, s.lName<br>
                <span class="sql-keyword">FROM</span> Staff s<br>
                <span class="sql-keyword">WHERE</span> <span class="sql-keyword">NOT EXISTS</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> *<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> PropertyForRent p<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> p.staffNo = s.staffNo<br>
                );
            </div>
            
            <div class="tip-box">
                <strong>Performance:</strong> EXISTS often faster than IN for large datasets - 
                it stops searching once it finds the first match!
            </div>
        </div>

        <!-- Slide 13: Correlated Subqueries -->
        <div class="slide">
            <h1>Correlated Subqueries</h1>
            <p>Subqueries that reference the outer query - executed for each row:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find properties with rent higher than average for their city</span><br>
                <span class="sql-keyword">SELECT</span> p1.propertyNo, p1.city, p1.rent<br>
                <span class="sql-keyword">FROM</span> PropertyForRent p1<br>
                <span class="sql-keyword">WHERE</span> p1.rent > (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(p2.rent)<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> PropertyForRent p2<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> p2.city = p1.city  <span class="sql-comment">-- References outer query!</span><br>
                );
            </div>
            
            <div class="warning-box">
                <strong>‚ö†Ô∏è Performance Warning:</strong> Correlated subqueries run once per row 
                in the outer query. Can be slow on large tables!
            </div>
        </div>

        <!-- Slide 14: Set Operations Overview -->
        <div class="slide">
            <h1>Set Operations</h1>
            <p>Combine results from multiple queries:</p>
            
            <div class="concept-box">
                <h3>SQL Set Operations:</h3>
                <ul>
                    <li><strong>UNION:</strong> All rows from both queries (removes duplicates)</li>
                    <li><strong>UNION ALL:</strong> All rows including duplicates</li>
                    <li><strong>INTERSECT:</strong> Only rows in both queries</li>
                    <li><strong>EXCEPT/MINUS:</strong> Rows in first but not second query</li>
                </ul>
            </div>
            
            <div class="sql-example">
                <span class="sql-comment">-- Cities with both branches and properties</span><br>
                <span class="sql-keyword">SELECT</span> city <span class="sql-keyword">FROM</span> Branch<br>
                <span class="sql-keyword">INTERSECT</span><br>
                <span class="sql-keyword">SELECT</span> city <span class="sql-keyword">FROM</span> PropertyForRent;
            </div>
            
            <div class="tip-box">
                <strong>Requirement:</strong> Queries must be union-compatible 
                (same number of columns, compatible data types)
            </div>
        </div>

        <!-- Slide 15: Complex Query Example -->
        <div class="slide">
            <h1>Putting It All Together</h1>
            <p>A complex real-world query combining multiple concepts:</p>
            
            <div class="sql-example">
                <span class="sql-comment">-- Find top-performing staff: manage > 2 properties AND earn above branch average</span><br>
                <span class="sql-keyword">SELECT</span> s.staffNo, s.fName, s.lName, s.salary,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(p.propertyNo) <span class="sql-keyword">AS</span> properties_managed<br>
                <span class="sql-keyword">FROM</span> Staff s<br>
                <span class="sql-keyword">LEFT JOIN</span> PropertyForRent p <span class="sql-keyword">ON</span> s.staffNo = p.staffNo<br>
                <span class="sql-keyword">WHERE</span> s.salary > (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(s2.salary)<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Staff s2<br>
                &nbsp;&nbsp;<span class="sql-keyword">WHERE</span> s2.branchNo = s.branchNo<br>
                )<br>
                <span class="sql-keyword">GROUP BY</span> s.staffNo, s.fName, s.lName, s.salary<br>
                <span class="sql-keyword">HAVING</span> <span class="sql-function">COUNT</span>(p.propertyNo) > <span class="sql-number">2</span><br>
                <span class="sql-keyword">ORDER BY</span> properties_managed <span class="sql-keyword">DESC</span>, s.salary <span class="sql-keyword">DESC</span>;
            </div>
        </div>

        <!-- Slide 16: Activity 2 - Subquery Challenge -->
        <div class="slide">
            <h1>Activity 2: Subquery Master <span class="emoji">üß©</span></h1>
            <div class="activity-box">
                <h3>20-Minute Challenge</h3>
                <p>Write queries using subqueries to find:</p>
                <ol>
                    <li>Properties with rent higher than the overall average</li>
                    <li>Staff who earn more than ALL managers</li>
                    <li>Branches where EVERY staff member earns > $15,000</li>
                    <li>Cities that have properties but NO branches</li>
                    <li>The branch with the highest total staff salaries</li>
                </ol>
                <p style="margin-top: 20px;"><strong>Bonus:</strong> Rewrite query #4 using both EXISTS and IN approaches!</p>
            </div>
            <button data-timer="20">Start 20-Minute Timer</button>
        </div>

        <!-- Slide 17: Query Optimization Tips -->
        <div class="slide">
            <h1>Query Optimization Best Practices</h1>
            
            <div class="comparison-table">
                <div class="comparison-card good">
                    <h3>‚úÖ DO</h3>
                    <ul>
                        <li>Use EXISTS for existence checks</li>
                        <li>Index foreign key columns</li>
                        <li>Filter early with WHERE</li>
                        <li>Use appropriate JOIN types</li>
                        <li>Consider query execution order</li>
                    </ul>
                </div>
                <div class="comparison-card bad">
                    <h3>‚ùå AVOID</h3>
                    <ul>
                        <li>SELECT * in production</li>
                        <li>Unnecessary nested subqueries</li>
                        <li>Correlated subqueries on large tables</li>
                        <li>DISTINCT when not needed</li>
                        <li>Functions in WHERE clauses</li>
                    </ul>
                </div>
            </div>
            
            <div class="demo-box">
                <strong>Pro Tip:</strong> Use EXPLAIN PLAN to understand how your database executes queries!
            </div>
        </div>

        <!-- Slide 18: Common Pitfalls -->
        <div class="slide">
            <h1>Common Mistakes to Avoid</h1>
            
            <div class="warning-box">
                <h3>üö´ Pitfall #1: NULL Handling</h3>
                <p>NULLs in subqueries can cause unexpected results:</p>
                <code>WHERE column NOT IN (subquery)</code>
                <p>Returns NO rows if subquery contains NULL!</p>
            </div>
            
            <div class="warning-box">
                <h3>üö´ Pitfall #2: Subquery Returns Multiple Rows</h3>
                <p>Using = with a multi-row subquery causes an error.</p>
                <p>Solution: Use IN, ANY, or ALL instead.</p>
            </div>
            
            <div class="warning-box">
                <h3>üö´ Pitfall #3: Forgetting Table Aliases</h3>
                <p>In correlated subqueries, always use clear aliases to avoid ambiguity.</p>
            </div>
        </div>

        <!-- Slide 19: Real-World Application -->
        <div class="slide">
            <h1>Real-World Scenario</h1>
            <p>Let's solve a business problem using advanced SQL:</p>
            
            <div class="demo-box">
                <h3>Business Requirement:</h3>
                <p>"Find underperforming branches: those with below-average property count 
                   and total staff salary below $50,000"</p>
            </div>
            
            <div class="sql-example">
                <span class="sql-keyword">WITH</span> BranchStats <span class="sql-keyword">AS</span> (<br>
                &nbsp;&nbsp;<span class="sql-keyword">SELECT</span> b.branchNo,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(<span class="sql-keyword">DISTINCT</span> p.propertyNo) <span class="sql-keyword">AS</span> prop_count,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">SUM</span>(s.salary) <span class="sql-keyword">AS</span> total_salary<br>
                &nbsp;&nbsp;<span class="sql-keyword">FROM</span> Branch b<br>
                &nbsp;&nbsp;<span class="sql-keyword">LEFT JOIN</span> PropertyForRent p <span class="sql-keyword">ON</span> b.city = p.city<br>
                &nbsp;&nbsp;<span class="sql-keyword">LEFT JOIN</span> Staff s <span class="sql-keyword">ON</span> b.branchNo = s.branchNo<br>
                &nbsp;&nbsp;<span class="sql-keyword">GROUP BY</span> b.branchNo<br>
                )<br>
                <span class="sql-keyword">SELECT</span> * <span class="sql-keyword">FROM</span> BranchStats<br>
                <span class="sql-keyword">WHERE</span> prop_count < (<span class="sql-keyword">SELECT</span> <span class="sql-function">AVG</span>(prop_count) <span class="sql-keyword">FROM</span> BranchStats)<br>
                &nbsp;&nbsp;<span class="sql-keyword">AND</span> total_salary < <span class="sql-number">50000</span>;
            </div>
        </div>

        <!-- Slide 20: Activity 3 - Integration -->
        <div class="slide">
            <h1>Activity 3: Integration Challenge <span class="emoji">üöÄ</span></h1>
            <div class="activity-box">
                <h3>25-Minute Complex Query Exercise</h3>
                <p><strong>Scenario:</strong> Management needs a comprehensive report!</p>
                <p>Create a query that shows:</p>
                <ul>
                    <li>All branches with their city</li>
                    <li>Count of properties in each city</li>
                    <li>Average property rent for the city</li>
                    <li>Number of staff at each branch</li>
                    <li>Whether the branch is "High Performing" (>3 properties AND >2 staff)</li>
                </ul>
                <p style="margin-top: 20px;"><strong>Requirements:</strong></p>
                <ul>
                    <li>Use at least one OUTER JOIN</li>
                    <li>Include a correlated subquery</li>
                    <li>Use CASE statement for performance classification</li>
                </ul>
            </div>
            <button data-timer="25">Start 25-Minute Timer</button>
        </div>

        <!-- IN-CLASS EXERCISES -->

        <!-- Slide 21: Exercise Overview -->
        <div class="slide">
            <h1>In-Class Exercises <span class="emoji">üèóÔ∏è</span></h1>
            <h2>Multi-JOIN & Aggregation Practice</h2>

            <div class="demo-box">
                <h3>Exercise Overview</h3>
                <p style="font-size: 1.2em;">Today, you'll practice writing complex SQL queries involving three-table JOINs and advanced aggregation with GROUP BY and HAVING clauses.</p>
            </div>

            <div class="activity-box">
                <h3>Learning Objectives</h3>
                <ul style="font-size: 1.15em;">
                    <li>‚úÖ Write multi-table INNER JOIN queries</li>
                    <li>‚úÖ Use table aliases for readability</li>
                    <li>‚úÖ Apply COUNT and AVG with GROUP BY</li>
                    <li>‚úÖ Filter aggregated results with HAVING</li>
                </ul>
            </div>
        </div>

        <!-- Slide 22: Exercise 1 -->
        <div class="slide">
            <h1>Exercise 1: Three-Table JOIN</h1>
            <h2>Individual Exercise (20 minutes)</h2>

            <div class="activity-box">
                <h3>Your Task:</h3>
                <p style="font-size: 1.1em;">Write an SQL query that requires a <strong>THREE-TABLE INNER JOIN</strong> and uses table aliases for readability.</p>
            </div>

            <div class="demo-box">
                <h3>Query Goal:</h3>
                <p style="font-size: 1.15em;">"Find the instructors who teach courses taken by student 'S10001', along with the course names and grades."</p>
            </div>

            <div class="demo-box">
                <h3>Schema:</h3>
                <div style="font-family: monospace; font-size: 0.95em;">
                    <strong>Student</strong>(studentID, firstName, lastName, email, major, GPA)<br>
                    <strong>Course</strong>(courseID, courseName, department, credits, instructorName)<br>
                    <strong>Enrollment</strong>(studentID, courseID, semester, grade, enrollDate)
                </div>
            </div>

            <div class="tip-box">
                <h3>Requirements:</h3>
                <ul style="font-size: 1.05em;">
                    <li>Join all three tables: Student, Course, and Enrollment</li>
                    <li>Use table aliases (e.g., s, c, e) for readability</li>
                    <li>Select: studentID, student name, course name, instructor name, grade</li>
                    <li>Filter for student 'S10001'</li>
                </ul>
            </div>

            <button data-timer="20">Start 20-Minute Timer</button>
        </div>

        <!-- Slide 23: Understanding Exercise 1 -->
        <div class="slide">
            <h1>Understanding: Three-Table JOINs</h1>

            <div class="tip-box">
                <h3>Solution:</h3>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;s.studentID,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;s.firstName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;s.lastName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;c.courseName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;c.instructorName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;e.grade<br>
                <span class="sql-keyword">FROM</span> Student s<br>
                <span class="sql-keyword">INNER JOIN</span> Enrollment e <span class="sql-keyword">ON</span> s.studentID = e.studentID<br>
                <span class="sql-keyword">INNER JOIN</span> Course c <span class="sql-keyword">ON</span> e.courseID = c.courseID<br>
                <span class="sql-keyword">WHERE</span> s.studentID = <span class="sql-string">'S10001'</span>;
            </div>

            <div class="demo-box">
                <h3>Key Insights:</h3>
                <ul style="font-size: 1.05em; line-height: 1.7;">
                    <li><strong>JOIN Order:</strong> Start with Student, join Enrollment (linking table), then Course</li>
                    <li><strong>Table Aliases:</strong> s, e, c make the query much more readable</li>
                    <li><strong>ON Conditions:</strong> Connect tables via foreign keys (studentID and courseID)</li>
                    <li><strong>INNER JOIN:</strong> Only returns rows where matches exist in all three tables</li>
                </ul>
            </div>
        </div>

        <!-- Slide 24: Understanding Exercise 1 (continued) -->
        <div class="slide">
            <h1>Understanding: JOIN Execution Flow</h1>

            <div class="concept-box">
                <h3>How the Database Processes This Query:</h3>
                <ol style="font-size: 1.05em; line-height: 1.8;">
                    <li><strong>Step 1:</strong> Filter Student table WHERE studentID = 'S10001'</li>
                    <li><strong>Step 2:</strong> JOIN with Enrollment using matching studentID values</li>
                    <li><strong>Step 3:</strong> JOIN result with Course using matching courseID values</li>
                    <li><strong>Step 4:</strong> Project (SELECT) the requested columns</li>
                </ol>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Sample Result Set:</h3>
                <table class="table-result">
                    <tr>
                        <th>studentID</th>
                        <th>firstName</th>
                        <th>lastName</th>
                        <th>courseName</th>
                        <th>instructorName</th>
                        <th>grade</th>
                    </tr>
                    <tr>
                        <td>S10001</td>
                        <td>John</td>
                        <td>Smith</td>
                        <td>Database Design</td>
                        <td>Dr. Reed</td>
                        <td>A</td>
                    </tr>
                    <tr>
                        <td>S10001</td>
                        <td>John</td>
                        <td>Smith</td>
                        <td>Data Structures</td>
                        <td>Dr. Johnson</td>
                        <td>B+</td>
                    </tr>
                    <tr>
                        <td>S10001</td>
                        <td>John</td>
                        <td>Smith</td>
                        <td>Algorithms</td>
                        <td>Dr. Martinez</td>
                        <td>A-</td>
                    </tr>
                </table>
            </div>

            <div class="tip-box">
                <strong>Pro Tip:</strong> Using aliases (s, e, c) is considered best practice for multi-table queries!
            </div>
        </div>

        <!-- Slide 25: Exercise 2 -->
        <div class="slide">
            <h1>Exercise 2: Aggregation & Grouping</h1>
            <h2>Individual Exercise (20 minutes)</h2>

            <div class="activity-box">
                <h3>Your Task:</h3>
                <p style="font-size: 1.1em;">Write SQL queries using <strong>COUNT and AVG</strong> with GROUP BY and a HAVING clause to answer two analytical questions about department data.</p>
            </div>

            <div class="demo-box">
                <h3>Question 1:</h3>
                <p>"Find each department's total number of courses and average credits per course. Only include departments offering more than 2 courses."</p>
            </div>

            <div class="demo-box">
                <h3>Question 2:</h3>
                <p>"Find each department's average course credits. Only include departments where the average credits is greater than or equal to 3.0."</p>
            </div>

            <div class="tip-box">
                <h3>Schema Reminder:</h3>
                <p style="font-family: monospace;">Course(courseID, courseName, department, credits, instructorName)</p>
            </div>

            <button data-timer="20">Start 20-Minute Timer</button>
        </div>

        <!-- Slide 26: Understanding Exercise 2 -->
        <div class="slide">
            <h1>Understanding: Aggregation Solutions</h1>

            <div class="tip-box">
                <h3>Solutions:</h3>
            </div>

            <div class="sql-example" style="font-size: 0.9em;">
                <span class="sql-comment">-- Question 1: Count and avg with HAVING for course count</span><br>
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;department,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(*) <span class="sql-keyword">AS</span> total_courses,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">AVG</span>(credits) <span class="sql-keyword">AS</span> avg_credits<br>
                <span class="sql-keyword">FROM</span> Course<br>
                <span class="sql-keyword">GROUP BY</span> department<br>
                <span class="sql-keyword">HAVING</span> <span class="sql-function">COUNT</span>(*) > 2;<br><br>

                <span class="sql-comment">-- Question 2: Avg with HAVING for credit threshold</span><br>
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;department,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">AVG</span>(credits) <span class="sql-keyword">AS</span> avg_credits<br>
                <span class="sql-keyword">FROM</span> Course<br>
                <span class="sql-keyword">GROUP BY</span> department<br>
                <span class="sql-keyword">HAVING</span> <span class="sql-function">AVG</span>(credits) >= 3.0;
            </div>
        </div>

        <!-- Slide 27: Understanding Exercise 2 (continued) -->
        <div class="slide">
            <h1>Understanding: GROUP BY vs HAVING</h1>

            <div class="concept-box">
                <h3>The Difference:</h3>
                <table class="table-result" style="font-size: 0.95em;">
                    <tr>
                        <th>Clause</th>
                        <th>Purpose</th>
                        <th>When It's Applied</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td><strong>WHERE</strong></td>
                        <td>Filter individual rows</td>
                        <td>Before grouping</td>
                        <td>WHERE credits > 3</td>
                    </tr>
                    <tr>
                        <td><strong>GROUP BY</strong></td>
                        <td>Organize rows into groups</td>
                        <td>After WHERE filtering</td>
                        <td>GROUP BY department</td>
                    </tr>
                    <tr>
                        <td><strong>HAVING</strong></td>
                        <td>Filter groups</td>
                        <td>After grouping</td>
                        <td>HAVING COUNT(*) > 2</td>
                    </tr>
                </table>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Sample Result (Question 1):</h3>
                <table class="table-result">
                    <tr>
                        <th>department</th>
                        <th>total_courses</th>
                        <th>avg_credits</th>
                    </tr>
                    <tr>
                        <td>Computer Science</td>
                        <td>5</td>
                        <td>3.4</td>
                    </tr>
                    <tr>
                        <td>Mathematics</td>
                        <td>4</td>
                        <td>3.25</td>
                    </tr>
                    <tr>
                        <td>Engineering</td>
                        <td>3</td>
                        <td>3.67</td>
                    </tr>
                </table>
            </div>

            <div class="warning-box">
                <strong>Important:</strong> You CANNOT use WHERE to filter on aggregated values. That's what HAVING is for!
            </div>
        </div>

        <!-- HOMEWORK SECTION -->

        <!-- Slide 28: Homework Overview -->
        <div class="slide">
            <h1>Homework Assignment <span class="emoji">üìù</span></h1>
            <h2>Week 8: OUTER JOINs & ROLLUP</h2>

            <div class="demo-box">
                <h3>Assignment Overview</h3>
                <p style="font-size: 1.15em;">This week's homework extends today's exercises by exploring OUTER JOIN syntax and advanced aggregation with ROLLUP/CUBE clauses for hierarchical reporting.</p>
            </div>

            <div class="tip-box">
                <h3>Due Date: <strong>Before Class Next Week</strong></h3>
                <p>Submit via Commit URL turned into D2L</p>
            </div>

            <div class="activity-box">
                <h3>Components:</h3>
                <ol style="font-size: 1.15em; line-height: 1.8;">
                    <li><strong>Homework Extension 1:</strong> INNER to OUTER JOIN Conversion (50 points)</li>
                    <li><strong>Homework Extension 2:</strong> ROLLUP/CUBE Report (50 points)</li>
                </ol>
                <p style="margin-top: 15px; font-size: 1.1em;"><strong>Total: 100 points</strong></p>
            </div>
        </div>

        <!-- Slide 29: Homework Extension 1 -->
        <div class="slide">
            <h1>Homework Extension 1: OUTER JOIN Conversion</h1>
            <h2>Building on Exercise 1</h2>

            <div class="activity-box">
                <h3>Task:</h3>
                <p style="font-size: 1.15em;">Rewrite the three-table JOIN query from Exercise 1 using a combination of <strong>LEFT or RIGHT OUTER JOIN</strong> syntax instead of INNER JOIN.</p>
            </div>

            <div class="demo-box">
                <h3>Original Query (INNER JOIN):</h3>
                <div class="sql-example" style="font-size: 0.8em;">
                    <span class="sql-keyword">SELECT</span> s.studentID, s.firstName, s.lastName,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.courseName, c.instructorName, e.grade<br>
                    <span class="sql-keyword">FROM</span> Student s<br>
                    <span class="sql-keyword">INNER JOIN</span> Enrollment e <span class="sql-keyword">ON</span> s.studentID = e.studentID<br>
                    <span class="sql-keyword">INNER JOIN</span> Course c <span class="sql-keyword">ON</span> e.courseID = c.courseID<br>
                    <span class="sql-keyword">WHERE</span> s.studentID = <span class="sql-string">'S10001'</span>;
                </div>
            </div>

            <div class="demo-box">
                <h3>Requirements:</h3>
                <ol style="font-size: 1.05em; line-height: 1.8;">
                    <li><strong>Rewrite using LEFT/RIGHT JOIN:</strong>
                        <ul style="margin-top: 8px;">
                            <li>Replace at least one INNER JOIN with LEFT or RIGHT JOIN</li>
                            <li>Ensure the query still returns the same results for student 'S10001'</li>
                        </ul>
                    </li>
                    <li><strong>Write explanation (150-200 words):</strong>
                        <ul style="margin-top: 8px;">
                            <li>How does the result set differ with OUTER JOIN?</li>
                            <li>In what scenario (with incomplete data) would OUTER JOIN show different results?</li>
                            <li>Provide a specific example of when you'd want to see NULL values</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>

        <!-- Slide 30: OUTER JOIN Guidance -->
        <div class="slide">
            <h1>Understanding OUTER JOINs</h1>

            <div class="concept-box">
                <h3>Hint for Homework Extension 1:</h3>
                <p style="font-size: 1.05em;">Consider what happens if a student is enrolled (in Student table) but has NO enrollment records yet. An INNER JOIN would exclude them, but a LEFT JOIN would include them with NULL values for course data.</p>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Example Conversion:</h3>
                <span class="sql-keyword">SELECT</span> s.studentID, s.firstName, s.lastName,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.courseName, c.instructorName, e.grade<br>
                <span class="sql-keyword">FROM</span> Student s<br>
                <span class="sql-keyword">LEFT JOIN</span> Enrollment e <span class="sql-keyword">ON</span> s.studentID = e.studentID<br>
                <span class="sql-keyword">LEFT JOIN</span> Course c <span class="sql-keyword">ON</span> e.courseID = c.courseID<br>
                <span class="sql-keyword">WHERE</span> s.studentID = <span class="sql-string">'S10001'</span>;
            </div>

            <div class="tip-box">
                <h3>Difference in Results:</h3>
                <p>If student 'S10001' exists but has zero enrollments:</p>
                <ul style="font-size: 1.05em;">
                    <li><strong>INNER JOIN:</strong> Returns 0 rows</li>
                    <li><strong>LEFT JOIN:</strong> Returns 1 row with NULLs for courseName, instructorName, grade</li>
                </ul>
            </div>
        </div>

        <!-- Slide 31: Homework Extension 2 -->
        <div class="slide">
            <h1>Homework Extension 2: ROLLUP Report</h1>
            <h2>Building on Exercise 2</h2>

            <div class="activity-box">
                <h3>Task:</h3>
                <p style="font-size: 1.15em;">Write a single SQL query that uses the <strong>ROLLUP clause</strong> to generate a report that includes department-level aggregations PLUS the overall total.</p>
            </div>

            <div class="demo-box">
                <h3>Report Requirements:</h3>
                <p>Your query should produce a result set showing:</p>
                <ol style="font-size: 1.05em; line-height: 1.8;">
                    <li>Each department's total course count and average credits</li>
                    <li>A grand total row showing overall course count and average credits across ALL departments</li>
                </ol>
            </div>

            <div class="warning-box">
                <h3>‚ö†Ô∏è Database Note:</h3>
                <p>ROLLUP syntax varies by database:</p>
                <ul style="font-size: 0.95em;">
                    <li><strong>MySQL/PostgreSQL:</strong> GROUP BY department WITH ROLLUP</li>
                    <li><strong>SQL Server:</strong> GROUP BY ROLLUP(department)</li>
                    <li><strong>Oracle:</strong> GROUP BY ROLLUP(department)</li>
                </ul>
                <p style="margin-top: 10px;">Use the syntax appropriate for your database!</p>
            </div>
        </div>

        <!-- Slide 32: ROLLUP Example -->
        <div class="slide">
            <h1>Understanding ROLLUP</h1>

            <div class="sql-example" style="font-size: 0.9em;">
                <h3>ROLLUP Query Example (MySQL):</h3>
                <span class="sql-keyword">SELECT</span> <br>
                &nbsp;&nbsp;&nbsp;&nbsp;department,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">COUNT</span>(*) <span class="sql-keyword">AS</span> total_courses,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;<span class="sql-function">AVG</span>(credits) <span class="sql-keyword">AS</span> avg_credits<br>
                <span class="sql-keyword">FROM</span> Course<br>
                <span class="sql-keyword">GROUP BY</span> department <span class="sql-keyword">WITH ROLLUP</span>;
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>Expected Result Set:</h3>
                <table class="table-result">
                    <tr>
                        <th>department</th>
                        <th>total_courses</th>
                        <th>avg_credits</th>
                    </tr>
                    <tr>
                        <td>Computer Science</td>
                        <td>5</td>
                        <td>3.40</td>
                    </tr>
                    <tr>
                        <td>Mathematics</td>
                        <td>4</td>
                        <td>3.25</td>
                    </tr>
                    <tr>
                        <td>Engineering</td>
                        <td>3</td>
                        <td>3.67</td>
                    </tr>
                    <tr style="background: #ffffcc;">
                        <td><strong>NULL (Grand Total)</strong></td>
                        <td><strong>12</strong></td>
                        <td><strong>3.42</strong></td>
                    </tr>
                </table>
            </div>

            <div class="tip-box">
                <strong>Key Point:</strong> The NULL in the department column indicates the grand total row!
            </div>
        </div>

        <!-- Slide 33: CUBE vs ROLLUP -->
        <div class="slide">
            <h1>BONUS: CUBE vs ROLLUP</h1>

            <div class="concept-box">
                <h3>Optional Enhancement (5 bonus points):</h3>
                <p style="font-size: 1.05em;">If your database supports CUBE, write a second query using CUBE instead of ROLLUP and explain the difference in output.</p>
            </div>

            <div class="demo-box">
                <h3>ROLLUP vs CUBE:</h3>
                <table class="table-result" style="font-size: 0.9em;">
                    <tr>
                        <th>Operation</th>
                        <th>What It Does</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>ROLLUP</strong></td>
                        <td>Creates subtotals + grand total in hierarchical order</td>
                        <td>When grouping columns have a natural hierarchy</td>
                    </tr>
                    <tr>
                        <td><strong>CUBE</strong></td>
                        <td>Creates all possible combinations of subtotals</td>
                        <td>When you want to analyze data from all dimensions</td>
                    </tr>
                </table>
            </div>

            <div class="sql-example" style="font-size: 0.85em;">
                <h3>CUBE Example (for multi-column grouping):</h3>
                <span class="sql-keyword">GROUP BY</span> <span class="sql-keyword">CUBE</span>(department, semester)
                <p style="margin-top: 10px;">This would produce:</p>
                <ul style="font-size: 0.95em;">
                    <li>Totals for each (department, semester) combination</li>
                    <li>Totals for each department across all semesters</li>
                    <li>Totals for each semester across all departments</li>
                    <li>Grand total across both dimensions</li>
                </ul>
            </div>
        </div>

        <!-- Slide 34: Submission Requirements -->
        <div class="slide">
            <h1>Submission Requirements <span class="emoji">‚úÖ</span></h1>

            <div class="demo-box">
                <h3>Format & Submission:</h3>
                <ul style="font-size: 1.15em; line-height: 1.8;">
                    <li><strong>File Format:</strong> Markdown document (.md)</li>
                    <li><strong>File Naming:</strong> LastName_FirstName_Week8_Homework.md</li>
                    <li><strong>Repository:</strong> Create file in your GitHub homework repository</li>
                    <li><strong>Submission Platform:</strong> Submit commit URL to D2L</li>
                    <li><strong>Due Date:</strong> Before class begins next week</li>
                </ul>
            </div>

            <div class="activity-box">
                <h3>Markdown Document Structure:</h3>
                <ol style="font-size: 1.1em; line-height: 1.8;">
                    <li><strong>Header:</strong> Name, date, course, "Week 8 Homework"</li>
                    <li><strong>Section 1:</strong> Extension 1 - OUTER JOIN Conversion
                        <ul style="margin-top: 8px;">
                            <li>Rewritten OUTER JOIN query</li>
                            <li>Explanation (150-200 words)</li>
                        </ul>
                    </li>
                    <li><strong>Section 2:</strong> Extension 2 - ROLLUP Report
                        <ul style="margin-top: 8px;">
                            <li>ROLLUP query with results</li>
                            <li>Screenshot or table showing output</li>
                            <li>(Optional) CUBE query for bonus points</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="demo-box">
                <h3>Grading:</h3>
                <table class="table-result" style="font-size: 0.95em;">
                    <tr>
                        <th>Component</th>
                        <th>Points</th>
                        <th>Criteria</th>
                    </tr>
                    <tr>
                        <td><strong>OUTER JOIN</strong></td>
                        <td>50</td>
                        <td>Correct syntax (25), Explanation (20), Example (5)</td>
                    </tr>
                    <tr>
                        <td><strong>ROLLUP Query</strong></td>
                        <td>50</td>
                        <td>Correct syntax (30), Results shown (15), Formatting (5)</td>
                    </tr>
                    <tr>
                        <td><strong>CUBE (Bonus)</strong></td>
                        <td>+5</td>
                        <td>Correct implementation and explanation</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Slide 35: Summary -->
        <div class="slide">
            <h1>Today's Takeaways <span class="emoji">üéì</span></h1>
            <h2>You Can Now:</h2>
            <ul>
                <li>‚úÖ Use LEFT, RIGHT, and FULL OUTER JOINs effectively</li>
                <li>‚úÖ Write scalar, row, and correlated subqueries</li>
                <li>‚úÖ Apply EXISTS/NOT EXISTS for efficient filtering</li>
                <li>‚úÖ Use ANY, ALL, and SOME with subqueries</li>
                <li>‚úÖ Combine queries with set operations</li>
                <li>‚úÖ Optimize complex queries for performance</li>
                <li>‚úÖ Avoid common SQL pitfalls</li>
                <li>‚úÖ Write multi-table INNER JOINs with aliases</li>
                <li>‚úÖ Use COUNT and AVG with GROUP BY and HAVING</li>
            </ul>
            <div class="demo-box">
                <p><strong>Next Lecture:</strong> Database Views and Stored Procedures</p>
                <p><strong>Homework:</strong> OUTER JOIN conversion & ROLLUP query (due next week)</p>
            </div>
        </div>

        <!-- Navigation Controls -->
        <div class="navigation">
            <button id="prevBtn">Previous</button>
            <span class="slide-counter">
                <span id="currentSlide">1</span> / <span id="totalSlides">36</span>
            </span>
            <button id="nextBtn">Next</button>
        </div>
    </div>

    <!-- Shared Presentation JavaScript -->
    <script src="../../js/presentation.js"></script>

    <!-- Lecture-Specific JavaScript -->
    <script>
        // Note: SQL example animations now handled by presentation.js

        // Lecture-specific: SQL keyword reference shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey) {
                switch(e.key) {
                    case 'S':
                        console.log('SQL Reference: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY');
                        break;
                    case 'J':
                        console.log('JOIN Types: INNER, LEFT, RIGHT, FULL OUTER, CROSS');
                        break;
                    case 'F':
                        console.log('Functions: COUNT, SUM, AVG, MIN, MAX');
                        break;
                }
            }
        });
    </script>
</body>
</html>